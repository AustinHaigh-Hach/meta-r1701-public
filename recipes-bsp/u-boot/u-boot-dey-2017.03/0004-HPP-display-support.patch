diff --git a/arch/arm/dts/imx6ul-r1701.dts b/arch/arm/dts/imx6ul-r1701.dts
index 5890c7f664..8b17dc930a 100644
--- a/arch/arm/dts/imx6ul-r1701.dts
+++ b/arch/arm/dts/imx6ul-r1701.dts
@@ -12,6 +12,7 @@
 /dts-v1/;
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/pwm/pwm.h>
 #include "imx6ul.dtsi"
 #include "imx6ul-ccimx6ul.dtsi"
 
@@ -38,6 +39,53 @@
             regulator-off-in-suspend;
         };
     };
+
+    // Color LCD backlight support.
+    lcd_backlight: backlight {
+        compatible = "pwm-backlight";
+        pwms = <&pwm2 0 50000 PWM_POLARITY_INVERTED>;
+
+        // a poor man's way to create a 1:1 relationship between the PWM value and the actual duty cycle
+        brightness-levels = <    0  1  2  3  4  5  6  7  8  9
+                                10 11 12 13 14 15 16 17 18 19
+                                20 21 22 23 24 25 26 27 28 29
+                                30 31 32 33 34 35 36 37 38 39
+                                40 41 42 43 44 45 46 47 48 49
+                                50 51 52 53 54 55 56 57 58 59
+                                60 61 62 63 64 65 66 67 68 69
+                                70 71 72 73 74 75 76 77 78 79
+                                80 81 82 83 84 85 86 87 88 89
+                                90 91 92 93 94 95 96 97 98 99
+                                100
+                            >;
+        default-brightness-level = <50>;
+        status = "disabled";
+    };
+
+    // PXP system - MXC PxP V4L2 driver (CONFIG_VIDEO_MXC_PXP_V4L2) - Color LCD related property
+    pxp_v4l2: pxp-v4l2 {
+        compatible = "fsl,imx6ul-pxp-v4l2", "fsl,imx6sx-pxp-v4l2", "fsl,imx6sl-pxp-v4l2";
+        status = "disabled";
+    };
+
+    // V5P0_EN Power regulator - enabled at boot time for MIP display support as well probe, audio etc.
+    reg_V5P0_EN: regulator-V5P0_EN {
+        compatible = "regulator-fixed";
+        regulator-name = "V5P0_EN";
+        regulator-min-microvolt = <3300000>;
+        regulator-max-microvolt = <3300000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_V5P0_EN_power>;
+        gpio = <&gpio5 6 GPIO_ACTIVE_HIGH>;
+        enable-active-high;
+        regulator-boot-on;
+        regulator-always-on;
+
+        // When power off key is pressed, system will enter in to suspend mode and we do not want this 5V power on.
+        regulator-state-mem {
+            regulator-off-in-suspend;
+        };
+    };
 };
 
 /* UART5 (Console) */
@@ -78,6 +126,154 @@
 	};
 };
 
+// PMIC - SW1A --> Powers several interfaces inside the module
+&int_3v3 {
+    regulator-min-microvolt = <700000>;
+    regulator-max-microvolt = <3300000>;
+    regulator-ramp-delay = <6250>;
+    regulator-boot-on;
+    regulator-always-on;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - SW1B --> Internal CPU power supply
+&vdd_arm_soc_in {
+    regulator-min-microvolt = <700000>;
+    regulator-max-microvolt = <1475000>;
+    regulator-ramp-delay = <6250>;
+    regulator-boot-on;
+    regulator-always-on;
+    regulator-state-mem {
+        regulator-on-in-suspend;
+        regulator-suspend-microvolt = <925000>;
+    };
+};
+
+// PMIC - SW2 --> DBuck regulator, Default 3.3 VDC, SOM_3V3_EXT
+&ext_3v3 {
+    regulator-min-microvolt = <2500000>;
+    regulator-max-microvolt = <3300000>;
+    regulator-ramp-delay = <6250>;
+    regulator-always-on;
+    regulator-boot-on;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - SW3 --> DDR3 power supply
+&vcc_ddr3 {
+    regulator-min-microvolt = <900000>;
+    regulator-max-microvolt = <1650000>;
+    regulator-always-on;
+    regulator-boot-on;
+    regulator-state-mem {
+        regulator-on-in-suspend;
+        regulator-suspend-microvolt = <1300000>;
+    };
+};
+
+// PMIC - SWBST --> Boost regulator, default 5VDC
+&swbst_reg {
+    regulator-min-microvolt = <5000000>;
+    regulator-max-microvolt = <5150000>;
+};
+
+// PMIC - VSNVS --> Internal CPU power supply
+&vdd_snvs_3v3 {
+    regulator-min-microvolt = <1000000>;
+    regulator-max-microvolt = <3000000>;
+    regulator-boot-on;
+    regulator-always-on;
+};
+
+// PMIC - VREFDDR --> DDR reference voltage
+&vrefddr {
+    regulator-boot-on;
+    regulator-always-on;
+};
+
+// PMIC - LDO1 --> CPU ADC reference voltage
+&vdda_adc_3v3 {
+    compatible = "regulator-fixed";
+    regulator-name = "vref-adc-3v3";
+    regulator-min-microvolt = <3300000>;
+    regulator-max-microvolt = <3300000>;
+    regulator-always-on;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - LDO2 --> LDO regulator, 1.5VDC  - TP13
+&ldo2_ext {
+    regulator-min-microvolt = <800000>;
+    regulator-max-microvolt = <1550000>;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - VCC_SD --> Wireless chip power supply
+&vdda_wlan {
+    regulator-min-microvolt = <2850000>;
+    regulator-max-microvolt = <3300000>;
+    regulator-always-on;
+    regulator-boot-on;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - V33 --> Internal CPU power supply
+&vdd_high_in {
+    regulator-min-microvolt = <2850000>;
+    regulator-max-microvolt = <3300000>;
+    regulator-boot-on;
+    regulator-always-on;
+};
+
+// Internal to SOM, Do not change any property in this node
+&ldo3_int {
+    regulator-min-microvolt = <1800000>;
+    regulator-max-microvolt = <3300000>;
+};
+
+// PMIC - LDO4 --> LDO regulator, 1.8 VDC, Powers the Voltage shifter chips for LCD display, TP14
+// DO NOT CHANGE MIN AND MAX VOLTAGE FOR THIS LDO. THIS LDO MUST PROVIDE ONLY 1.8VDC. This voltage is given to color
+// LCD and if it is more than 1.8VDC then it will damange LCD.
+&ldo4_ext {
+    regulator-min-microvolt = <1800000>;
+    regulator-max-microvolt = <1800000>;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - VCOIN --> Coin cell charger, 3 VDC
+&vcoin_chg {
+    regulator-min-microvolt = <2500000>;
+    regulator-max-microvolt = <3300000>;
+};
+
+
+// PXP video module
+&pxp_v4l2 {
+    status = "okay";
+};
+
+&pxp {
+    status = "okay";
+};
+
+// enable backlight
+&lcd_backlight {
+    status = "okay";
+};
+
+
 &caam_keyblob {
 	status = "disabled";
 };
@@ -98,8 +294,15 @@
 	status = "disabled";
 };
 
+
+// Color LCD backlight PWM
 &pwm2 {
-	status = "disabled";
+    pinctrl-names = "default","pwm";
+    pinctrl-0 = <&pinctrl_pwm2_gpio>;
+    pinctrl-1 = <&pinctrl_pwm2_pwm>;
+    clocks =    <&clks IMX6UL_CLK_PWM2>,
+    <&clks IMX6UL_CLK_PWM2>;
+    status = "okay";
 };
 
 &pwm3 {
@@ -171,6 +374,74 @@
     };
 };
 
+
+// Parallel LCD
+&lcdif {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_lcdif>;
+    gpios = <&gpio5 0  GPIO_ACTIVE_LOW>,    // LCD_PWR_EN&
+            <&gpio3 4  GPIO_ACTIVE_LOW>,    // LCD_RESET&
+            <&gpio5 9  GPIO_ACTIVE_LOW>;    // LCD_STANDBY&
+    display = <&com35h3p29ulc>;
+    lcd-supply = <&ldo4_ext>;
+    status = "okay";
+
+    // 3.5 inch Ortustech - COM35H3P29ULC color VGA portrait display
+    com35h3p29ulc: display@0 {
+
+        // 16 Bit Color mode
+        bits-per-pixel = <16>;
+
+        // number of data lines.  Could be <8>, <16>, <18> or <24>
+        bus-width = <16>;
+
+        // Display panel timning table.
+        display-timings {
+            native-mode = <&timing0>;
+
+            // VGA - Ortustech Display (Portrait Mode)
+            timing0: 480x640 {
+
+                // Pixel clock in Hz 19.8 MHz Typical
+                clock-frequency = <19800000>;
+
+                // display resolution */
+                hactive = <480>;
+                vactive = <640>;
+
+                // HSYNC Cycle (508) = HFP + HBP + HSYNC_LEN + 480
+                hfront-porch = <8>;
+                hback-porch = <10>;
+                hsync-len = <10>;
+
+                // VSYNC Cycle (650) = VFP + VBP + VSYNC_LEN + 640
+                vback-porch = <3>;
+                vfront-porch = <4>;
+                vsync-len = <3>;
+
+                // hsync/vsync pulse is active low/high/ignored */
+                // Ortustech display expect HSYNC and VSYNC as active low for valid data transfer
+                hsync-active = <0>;
+                vsync-active = <0>;
+
+                // data-enable pulse is active low/high/ignored
+                // Ortustech display expect data valid signal as active HIGH
+                de-active = <1>;
+
+                // Pixel Clock,
+                //  - active high = drive pixel data on rising edge sample data on falling edge
+                //  - active low  = drive pixel data on falling edge sample data on rising edge
+                //  - ignored     = ignored
+                //
+                // Ortustech display latch all LCD data on falling edge
+                //
+                pixelclk-active = <1>;
+            };
+        };
+    };
+};
+
+
 /* Pin mux configuration */
 &iomuxc {
 	pinctrl-names = "default";
@@ -195,6 +466,45 @@
             >;
         };
 
+        // Ortustech VGA LCD pins
+        pinctrl_lcdif: lcdifdatactrlgrp {
+            fsl,pins = <
+                MX6UL_PAD_LCD_DATA00__LCDIF_DATA00      0x79
+                MX6UL_PAD_LCD_DATA01__LCDIF_DATA01      0x79
+                MX6UL_PAD_LCD_DATA02__LCDIF_DATA02      0x79
+                MX6UL_PAD_LCD_DATA03__LCDIF_DATA03      0x79
+                MX6UL_PAD_LCD_DATA04__LCDIF_DATA04      0x79
+                MX6UL_PAD_LCD_DATA05__LCDIF_DATA05      0x79
+                MX6UL_PAD_LCD_DATA06__LCDIF_DATA06      0x79
+                MX6UL_PAD_LCD_DATA07__LCDIF_DATA07      0x79
+                MX6UL_PAD_LCD_DATA08__LCDIF_DATA08      0x79
+                MX6UL_PAD_LCD_DATA09__LCDIF_DATA09      0x79
+                MX6UL_PAD_LCD_DATA10__LCDIF_DATA10      0x79
+                MX6UL_PAD_LCD_DATA11__LCDIF_DATA11      0x79
+                MX6UL_PAD_LCD_DATA12__LCDIF_DATA12      0x79
+                MX6UL_PAD_LCD_DATA13__LCDIF_DATA13      0x79
+                MX6UL_PAD_LCD_DATA14__LCDIF_DATA14      0x79
+                MX6UL_PAD_LCD_DATA15__LCDIF_DATA15      0x79
+                MX6UL_PAD_LCD_ENABLE__LCDIF_ENABLE      0x79
+                MX6UL_PAD_LCD_HSYNC__LCDIF_HSYNC        0x79
+                MX6UL_PAD_LCD_VSYNC__LCDIF_VSYNC        0x79
+                MX6UL_PAD_LCD_CLK__LCDIF_CLK            0x17050
+            >;
+        };
+
+        // Color LCD back light control signal
+        pinctrl_pwm2_pwm: pwm2grp-pwm {
+            fsl,pins = <
+                MX6UL_PAD_GPIO1_IO09__PWM2_OUT          0x110b0
+            >;
+        };
+        pinctrl_pwm2_gpio: pwm2grp-gpio {
+            fsl,pins = <
+                MX6UL_PAD_GPIO1_IO09__GPIO1_IO09          0x1f0b0
+           >;
+       };
+
+
 		// Console
 		pinctrl_uart5: uart5grp {
 			fsl,pins = <
@@ -246,6 +556,9 @@
                 MX6UL_PAD_SNVS_TAMPER9__GPIO5_IO09      0x10b0  // LCD2_STANDBY&
                 MX6UL_PAD_SNVS_TAMPER0__GPIO5_IO00      0x10b0  // LCD2_PWR_EN&
 
+                MX6UL_PAD_GPIO1_IO05__GPIO1_IO05        0x10b0  // SPARE_W1_TP65
+                MX6UL_PAD_LCD_DATA16__GPIO3_IO21        0x10b0  // SPARE_W10_TP1
+                MX6UL_PAD_NAND_DQS__GPIO4_IO16          0x10b0  // SPARE_M2_TP27
 			>;
 		};
 	};
diff --git a/board/digi/r1701/Kconfig b/board/digi/r1701/Kconfig
index dc4e4b5885..1766f957a5 100644
--- a/board/digi/r1701/Kconfig
+++ b/board/digi/r1701/Kconfig
@@ -18,7 +18,11 @@ config SYS_CONFIG_NAME
 
 config VIDEO
     bool
-    default n
+    default y
+
+config VIDEO_MXS
+    bool
+    default y
 
 config VIDEO_R1701
     bool "R1701 video driver"
diff --git a/board/digi/r1701/r1701.c b/board/digi/r1701/r1701.c
index 6f76177609..63563574d1 100644
--- a/board/digi/r1701/r1701.c
+++ b/board/digi/r1701/r1701.c
@@ -56,8 +56,6 @@ DECLARE_GLOBAL_DATA_PTR;
 unsigned int board_version = CARRIERBOARD_VERSION_UNDEFINED;
 unsigned int board_id = CARRIERBOARD_ID_UNDEFINED;
 
-int r1701_mpp_on_off,
-    r1701_mpp_bklt;
 struct spi_slave *r1701_mpp_dev;
 
 // We do not use I2C multi bus and spare console gpio lines.
@@ -421,6 +419,37 @@ static iomux_v3_cfg_t const mpp_pads[] = {
 
 };
 
+static iomux_v3_cfg_t const hpp_pads[] = {
+	MX6_PAD_SNVS_TAMPER6__GPIO5_IO06 | MUX_PAD_CTRL(NO_PAD_CTRL),  // V5P0_EN
+
+    MX6_PAD_GPIO1_IO09__PWM2_OUT | MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_BKLT_PWM
+
+    MX6_PAD_SNVS_TAMPER0__GPIO5_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_PWR_EN
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE | MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD_DATA_VALID
+	MX6_PAD_SNVS_TAMPER9__GPIO5_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD_STANDBY
+	MX6_PAD_LCD_RESET__LCDIF_RESET | MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD_RESET
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC | MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD_HSYNC
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC | MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD_VSYNC
+	MX6_PAD_LCD_CLK__LCDIF_CLK | MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_CLK
+
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA0_SW
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA1_SW
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA2_SW
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA3_SW
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA4_SW
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA5_SW
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA6_SW
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA7_SW
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA8_SW
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA9_SW
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA10_SW
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA11_SW
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA12_SW
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA13_SW
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA14_SW
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15| MUX_PAD_CTRL(NO_PAD_CTRL),  // LCD2_DATA15_SW
+};
+
 // function called by mxc_spi driver to determine which GPIO pin is connected to CS
 int board_spi_cs_gpio(unsigned bus, unsigned cs){
     int pin = IMX_GPIO_NR(1, 3);
@@ -431,24 +460,8 @@ int board_spi_cs_gpio(unsigned bus, unsigned cs){
     return pin;
 }
 
-static __u16 reverse_u16(__u16 value){
-
-    /* No need to convert entire 16 bit, we only care for A0-A9 line address bits */
-    return (((value & 0b0000000000000001) ? 0b0000001000000000 : 0 ) | \
-            ((value & 0b0000000000000010) ? 0b0000000100000000 : 0 ) | \
-            ((value & 0b0000000000000100) ? 0b0000000010000000 : 0 ) | \
-            ((value & 0b0000000000001000) ? 0b0000000001000000 : 0 ) | \
-            ((value & 0b0000000000010000) ? 0b0000000000100000 : 0 ) | \
-            ((value & 0b0000000000100000) ? 0b0000000000010000 : 0 ) | \
-            ((value & 0b0000000001000000) ? 0b0000000000001000 : 0 ) | \
-            ((value & 0b0000000010000000) ? 0b0000000000000100 : 0 ) | \
-            ((value & 0b0000000100000000) ? 0b0000000000000010 : 0 ) | \
-            ((value & 0b0000001000000000) ? 0b0000000000000001 : 0 ));
-}
-
 int setup_mpp_display(){
-    imx_iomux_v3_setup_multiple_pads(mpp_pads,
-            ARRAY_SIZE(mpp_pads));
+    imx_iomux_v3_setup_multiple_pads(mpp_pads, ARRAY_SIZE(mpp_pads));
 
     // turn on backlight:
     int v5_enable = IMX_GPIO_NR(5, 6);
@@ -459,13 +472,13 @@ int setup_mpp_display(){
     }
     gpio_direction_output(v5_enable, 1);
 
-    r1701_mpp_bklt = IMX_GPIO_NR(5, 5);
+    int mpp_bklt = IMX_GPIO_NR(5, 5);
 
-    if(gpio_request(r1701_mpp_bklt, "LCD_BKLT_EN")){
-        printf("ERROR requesting gpio pin %d\n", r1701_mpp_bklt);
+    if(gpio_request(mpp_bklt, "LCD_BKLT_EN")){
+        printf("ERROR requesting gpio pin %d\n", mpp_bklt);
         return 1;
     }
-    gpio_direction_output(r1701_mpp_bklt, 1);
+    gpio_direction_output(mpp_bklt, 1);
 
     int extcom = IMX_GPIO_NR(5, 8);
     if(gpio_request(extcom, "LCD_EXTCOM")){
@@ -474,12 +487,12 @@ int setup_mpp_display(){
     }
     gpio_direction_output(extcom, 1);
 
-    r1701_mpp_on_off = IMX_GPIO_NR(5, 1);
-    if(gpio_request(r1701_mpp_on_off, "LCD_ON_OFF")){
-        printf("ERROR requesting gpio pin %d\n", r1701_mpp_on_off);
+    int mpp_on_off = IMX_GPIO_NR(5, 1);
+    if(gpio_request(mpp_on_off, "LCD_ON_OFF")){
+        printf("ERROR requesting gpio pin %d\n", mpp_on_off);
         return 1;
     }
-    gpio_direction_output(r1701_mpp_on_off, 0);
+    gpio_direction_output(mpp_on_off, 0);
 
     r1701_mpp_dev = spi_setup_slave(0, 0, 2000000, SPI_MODE_0 | SPI_CS_HIGH);
 
@@ -489,13 +502,50 @@ int setup_mpp_display(){
 
     spi_xfer(r1701_mpp_dev, 8*sizeof(HachLogoMPP_SPI_buf), HachLogoMPP_SPI_buf, HachLogoMPP_SPI_buf, SPI_XFER_ONCE);
 
-    gpio_set_value(r1701_mpp_on_off, 1);
+    gpio_set_value(mpp_on_off, 1);
 
     return 0;
 }
 
 int setup_hpp_display(){
-    //TODO
+    imx_iomux_v3_setup_multiple_pads(hpp_pads, ARRAY_SIZE(hpp_pads));
+
+    int v5_enable = IMX_GPIO_NR(5, 6);
+    if(gpio_request(v5_enable, "V5P0")){
+        printf("ERROR requesting gpio pin %d\n", v5_enable);
+        return 1;
+    }
+    gpio_direction_output(v5_enable, 1);
+
+
+    int lcd_pwr_en = IMX_GPIO_NR(5, 0);
+    if(gpio_request(lcd_pwr_en, "LCD2_PWR_EN")){
+        printf("ERROR requesting gpio pin %d\n", lcd_pwr_en);
+        return 1;
+    }
+    gpio_direction_output(lcd_pwr_en, 0);
+    udelay(50000);
+
+
+    int lcd_reset = IMX_GPIO_NR(3, 4);
+    if(gpio_request(lcd_reset, "LCD_RESET")){
+        printf("ERROR requesting gpio pin %d\n", lcd_reset);
+        return 1;
+    }
+    gpio_direction_output(lcd_reset, 0);
+    udelay(20000);
+    gpio_set_value(lcd_reset, 1);
+    udelay(10000);
+
+
+    int lcd_standby = IMX_GPIO_NR(5, 9);
+    if(gpio_request(lcd_standby, "LCD_STANDBY")){
+        printf("ERROR requesting gpio pin %d\n", lcd_standby);
+        return 1;
+    }
+    gpio_direction_output(lcd_standby, 1);
+    gpio_set_value(lcd_standby, 1);
+
     return 0;
 }
 #endif
@@ -525,11 +575,26 @@ int board_init(void)
 #endif
 
 #ifdef CONFIG_VIDEO_R1701
-    if(strcmp(getenv("model-type"), "HQ_MPP") == 0)
-        setup_mpp_display();
-    else
-        setup_hpp_display();
-#endif
+    struct fb_videomode mode = {
+        .name = "R1701 display",
+        .refresh = 0,   // ignored by driver
+        .xres = 480,
+        .yres = 640,
+	    .pixclock = 50510,
+	    .left_margin = 0,
+	    .right_margin = 0,
+	    .upper_margin = 0,
+	    .lower_margin = 0,
+	    .hsync_len = 10,
+	    .vsync_len = 3,
+	    .sync = 0,
+	    .vmode = 0,
+	    .flag = 0
+    };
+
+    mxs_lcd_panel_setup(mode, 16, MXS_LCDIF_BASE);  // TODO: double check last param
+    setup_hpp_display();
+#endif 
 
 	return 0;
 }
@@ -579,6 +644,13 @@ int board_late_init(void)
 
 	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
 
+#ifdef CONFIG_VIDEO_R1701
+    if(strcmp(getenv("model-type"), "HQ_MPP") == 0)
+        setup_mpp_display();
+    else
+        ;//setup_hpp_display();
+#endif
+
 	return 0;
 }
 
diff --git a/configs/r1701_defconfig b/configs/r1701_defconfig
index 63ba777e56..9c06ae796c 100644
--- a/configs/r1701_defconfig
+++ b/configs/r1701_defconfig
@@ -27,4 +27,8 @@ CONFIG_RNG_SW_TEST=y
 CONFIG_DM_GPIO=y
 CONFIG_PHYLIB=y
 CONFIG_IMX_THERMAL=y
-CONFIG_DM_VIDEO=y
+CONFIG_VIDEO=y
+CONFIG_VIDEO_MXS=y
+CONFIG_VIDEO_LOGO=y
+CONFIG_VIDEO_BMP_LOGO=y
+
diff --git a/include/configs/r1701.h b/include/configs/r1701.h
index 46446f3b41..395d8e8971 100644
--- a/include/configs/r1701.h
+++ b/include/configs/r1701.h
@@ -288,4 +288,14 @@
 
 #define CONFIG_MXC_SPI
 
+/* HPP video support */
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_CMD_BMP
+#define CONFIG_PWM_IMX
+#define CONFIG_IMX6_PWM_PER_CLK 66000000
+
+/*#define CONFIG_VIDEO
+#define CONFIG_VIDEO_MXS
+*/
+
 #endif /* R1701_CONFIG_H */
